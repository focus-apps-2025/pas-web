import React, { useState, useCallback, useEffect, useRef } from 'react';
import {
  Container,
  Paper,
  Typography,
  Button,
  Box,
  Grid,
  Alert,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Card,
  CardContent,
  LinearProgress,
  IconButton,
  Chip,
  Stepper,
  Step,
  StepLabel,
  TextField
} from '@mui/material';
import {
  UploadFile,
  Download,
  CompareArrows,
  Info,
  Delete,
  NavigateNext
} from '@mui/icons-material';
import { DataGrid } from '@mui/x-data-grid';
import * as XLSX from 'xlsx';
import { AlignCenter } from 'lucide-react';

// Convert your 2D array (with headers in row[0]) into DataGrid rows
const buildGridData = (data) => {
  if (!data || data.length < 2) return { rows: [], columns: [] };

  const headers = data[0];

  const rows = data.slice(1).map((row, index) => {
    let rowObj = { id: index + 1 };
    headers.forEach((header, colIndex) => {
      rowObj[header] = row[colIndex];
    });
    return rowObj;
  });

  const columns = headers.map((header) => ({
    field: header,
    headerName: header,
    flex: 1,
    editable: header === "Phy Stock",
  }));

  return { rows, columns };
};

const StockComparison = () => {
  const [dmsData, setDmsData] = useState(null);
  const [physicalData, setPhysicalData] = useState(null);
  const [beforeData, setBeforeData] = useState(null);
  const [afterData, setAfterData] = useState(null);
  const [reportData, setReportData] = useState(null);
  const [dmsFileName, setDmsFileName] = useState('');
  const [physicalFileName, setPhysicalFileName] = useState('');
  const [beforeFileName, setBeforeFileName] = useState('');
  const [afterFileName, setAfterFileName] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const [currentStep, setCurrentStep] = useState(0);
  const [originalReportData, setOriginalReportData] = useState(null);
  const [processedDmsMap, setProcessedDmsMap] = useState(null);
  const [processedPhysicalMap, setProcessedPhysicalMap] = useState(null);
  const [dmsInfoMap, setDmsInfoMap] = useState(null);
  const [initialDmsMapForReport, setInitialDmsMapForReport] = useState(null);

  // TVS Template state
  const [tvsTemplateData, setTvsTemplateData] = useState(null);
  const [dealerId, setDealerId] = useState('');
  const [branchId, setBranchId] = useState('');
  const [manufacturerId, setManufacturerId] = useState('');
  const [taxable, setTaxableId] = useState('');
  const [mismatchedEntries, setMismatchedEntries] = useState([]);
  const [unmatchedEntries, setUnmatchedEntries] = useState({
    mismatchedRack: [],
    emptyRack: [],
    partNotFound: []
  });
  const [tvsAfterFileName, setTvsAfterFileName] = useState('');
  const [tvsAfterData, setTvsAfterData] = useState(null);
  const [forceUpdate, setForceUpdate] = useState(0);
  const primaryColor = '#004f98';
  const steps = ['Initial Report', 'Before Adjustment', 'After Adjustment'];

  const [dupStats, setDupStats] = useState(null);
  const tvsAfterInputRef = useRef(null);

  // NEW: summary heading input (Dealer/Showroom name)
  const [summaryHeader, setSummaryHeader] = useState('');

  const handleFileUpload = (event, fileType) => {
    const file = event.target.files[0];
    if (!file) return;

    setError('');

    if (fileType === 'dms') {
      setDmsFileName(file.name);
    } else if (fileType === 'physical') {
      setPhysicalFileName(file.name);
    } else if (fileType === 'before') {
      setBeforeFileName(file.name);
    } else if (fileType === 'after') {
      setAfterFileName(file.name);
    } else if (fileType === 'tvsAfter') {
      setTvsAfterFileName(file.name);
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      let jsonData;
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        if (fileType === 'dms') {
          setDmsData(jsonData);
        } else if (fileType === 'physical') {
          setPhysicalData(jsonData);
        } else if (fileType === 'before') {
          setBeforeData(jsonData);
        } else if (fileType === 'after') {
          setAfterData(jsonData);
        } else if (fileType === 'tvsAfter') {
          setTvsAfterData(jsonData);
        }
      } catch (err) {
        setError(`Error reading ${fileType} file: ${err.message}`);
      }
    };
    reader.readAsArrayBuffer(file);
  };

  const clearFile = (fileType) => {
    if (fileType === 'dms') {
      setDmsData(null);
      setDmsFileName('');
      resetAll();
    } else if (fileType === 'physical') {
      setPhysicalData(null);
      setPhysicalFileName('');
      resetAll();
    } else if (fileType === 'before') {
      setBeforeData(null);
      setBeforeFileName('');
      if (currentStep === 1) {
        generateInitialReport();
      }
    } else if (fileType === 'after') {
      setAfterData(null);
      setAfterFileName('');
      if (currentStep === 2) {
        if (beforeData) {
          applyBeforeFileAdjustment();
        } else {
          generateInitialReport();
        }
      }
    } else if (fileType === 'tvsAfter') {
      setTvsAfterData(null);
      setTvsAfterFileName('');
      setTvsTemplateData(null);
      if (tvsAfterInputRef?.current) tvsAfterInputRef.current.value = null;
    }
  };

  const findColumnIndex = (headers, possibleNames) => {
    if (!headers || headers.length === 0) return -1;
    for (let name of possibleNames) {
      const index = headers.findIndex(header =>
        header !== null && header !== undefined && String(header).toLowerCase().includes(name.toLowerCase())
      );
      if (index !== -1) return index;
    }
    return -1;
  };

  const generateInitialReport = () => {
    if (!dmsData || !physicalData) {
      setError('Please upload both DMS and Physical files first.');
      return;
    }

    setLoading(true);
    setError('');
    setBeforeData(null);
    setBeforeFileName('');
    setAfterData(null);
    setAfterFileName('');
    setCurrentStep(0);
    setTvsTemplateData(null);

    setTimeout(() => {
      try {
        const dmsHeaders = dmsData[0] || [];
        const physicalHeaders = physicalData[0] || [];

        const findColumn = (headers, names) => {
          const index = findColumnIndex(headers, names);
          if (index === -1) {
            console.warn(`Could not find a column with names like: ${names.join(', ')}`);
          }
          return index;
        };

        const partNoDmsIndex = findColumn(dmsHeaders, ['part no', 'partno', 'part number', 'part code', 'item']);
        const qtyDmsIndex = findColumn(dmsHeaders, ['total stock', 'stock', 'qty', 'quantity', 'balance']);
        const descDmsIndex = findColumn(dmsHeaders, ['description', 'material description', 'item description']);
        const ndpDmsIndex = findColumn(dmsHeaders, ['ndp', 'net dealer price', 'unit price']);

        const partNoPhysicalIndex = findColumn(physicalHeaders, ['part no', 'partno', 'part number', 'part code', 'item']);
        const qtyPhysicalIndex = findColumn(physicalHeaders, ['qty', 'quantity', 'stock', 'phy qty', 'count']);
        const ndpIndex = findColumn(physicalHeaders, ['ndp', 'net dealer price', 'unit price']);
        const mrpIndex = findColumn(physicalHeaders, ['mrp', 'max retail price', 'retail price']);
        const descIndex = findColumn(physicalHeaders, ['description', 'material description', 'item description']);
        const locationIndex = findColumn(physicalHeaders, ['location', 'bin', 'storage']);
        const rackIndex = findColumn(physicalHeaders, ['rack', 'shelf', 'row']);

        if (partNoDmsIndex === -1 || qtyDmsIndex === -1) {
          throw new Error('DMS file must contain Part Number and Stock/Quantity columns.');
        }
        if (partNoPhysicalIndex === -1 || qtyPhysicalIndex === -1) {
          throw new Error('Physical file must contain Part Number and Quantity columns.');
        }

        const dmsMap = new Map();
        const dmsInfo = new Map();
        const physicalMap = new Map();

        for (let i = 1; i < dmsData.length; i++) {
          const row = dmsData[i];
          if (!row || row[partNoDmsIndex] === undefined || row[partNoDmsIndex] === null) continue;
          const partNo = String(row[partNoDmsIndex]).trim().toUpperCase();
          const quantity = parseFloat(row[qtyDmsIndex]) || 0;
          if (partNo) {
            dmsMap.set(partNo, (dmsMap.get(partNo) || 0) + quantity);
            if (!dmsInfo.has(partNo)) {
              dmsInfo.set(partNo, {
                description: descDmsIndex !== -1 ? String(row[descDmsIndex] || '').trim() : '',
                ndp: ndpDmsIndex !== -1 ? parseFloat(row[ndpDmsIndex]) || 0 : 0
              });
            }
          }
        }

        for (let i = 1; i < physicalData.length; i++) {
          const row = physicalData[i];
          if (!row || row[partNoPhysicalIndex] === undefined || row[partNoPhysicalIndex] === null) continue;
          const partNo = String(row[partNoPhysicalIndex]).trim().toUpperCase();
          const quantity = parseFloat(row[qtyPhysicalIndex]) || 0;
          if (partNo) {
            const existing = physicalMap.get(partNo);
            if (existing) {
              existing.quantity += quantity;
            } else {
              physicalMap.set(partNo, {
                quantity: quantity,
                ndp: ndpIndex !== -1 ? parseFloat(row[ndpIndex]) || 0 : 0,
                mrp: mrpIndex !== -1 ? parseFloat(row[mrpIndex]) || 0 : 0,
                description: descIndex !== -1 ? String(row[descIndex] || '').trim() : '',
                location: locationIndex !== -1 ? String(row[locationIndex] || '').trim() : '',
                rack: rackIndex !== -1 ? String(row[rackIndex] || '').trim() : ''
              });
            }
          }
        }

        setProcessedDmsMap(new Map(dmsMap));
        setProcessedPhysicalMap(new Map(physicalMap));
        setDmsInfoMap(new Map(dmsInfo));
        setInitialDmsMapForReport(new Map(dmsMap));

        const report = generateReportFromMaps(dmsMap, physicalMap, dmsInfo, initialDmsMapForReport || dmsMap);
        setReportData(report);

        const dmsPartNosRaw = dmsData.slice(1)
          .map(r => r[partNoDmsIndex])
          .filter(p => p !== undefined && p !== null && String(p).trim() !== '')
          .map(p => String(p).trim().toUpperCase());

        const physPartNosRaw = physicalData.slice(1)
          .map(r => r[partNoPhysicalIndex])
          .filter(p => p !== undefined && p !== null && String(p).trim() !== '')
          .map(p => String(p).trim().toUpperCase());

        const dmsDupCount = dmsPartNosRaw.length;
        const physDupCount = physPartNosRaw.length;

        const dmsSet = new Set(dmsPartNosRaw);
        const physSet = new Set(physPartNosRaw);

        const physOnlyDupCount = physPartNosRaw.filter(p => !dmsSet.has(p)).length;
        const physOnlyUniqueCount = [...physSet].filter(p => !dmsSet.has(p)).length;
        const physUniqueCount = physSet.size;

        setDupStats({
          dmsDupCount,
          physDupCount,
          physOnlyDupCount,
          physOnlyUniqueCount,
          physUniqueCount
        });

      } catch (err) {
        setError(`Error: ${err.message}`);
      } finally {
        setLoading(false);
      }
    }, 100);
  };

  const generateReportFromMaps = (currentDmsMap, currentPhysicalMap, dmsInfoMap, initialDmsMap) => {
    const report = [];
    const headers = [
      'SI no', 'PartNo', 'Part Description',
      'DMS Stk', 'Phy Stock', 'Short', 'Excess',
      'NDP', 'MRP',
      'Shortage Value', 'Excess Value',
      'Total NDP Value', 'Total MRP Value',
      'Original DMS Stk', 'Original DMS Value'
    ];
    report.push(headers);

    const detailedRows = [];
    const allPartNumbers = new Set([...currentPhysicalMap.keys(), ...currentDmsMap.keys(), ...dmsInfoMap.keys()]);

    let totalDms = 0, totalPhysical = 0, totalShort = 0, totalExcess = 0,
      totalShortageValue = 0, totalExcessValue = 0,
      totalPhysicalNdpValue = 0, totalPhysicalMrpValue = 0,
      totalOriginalDmsStk = 0, totalOriginalDmsValue = 0;

    for (const partNo of allPartNumbers) {
      const physicalInfo = currentPhysicalMap.get(partNo);
      const dmsPartInfo = dmsInfoMap.get(partNo);

      const dmsQty = currentDmsMap.get(partNo) || 0;
      const physicalQty = physicalInfo ? physicalInfo.quantity : 0;

      const description = (physicalInfo ? physicalInfo.description : '') || (dmsPartInfo ? dmsPartInfo.description : '');
      const ndp = (physicalInfo ? physicalInfo.ndp : 0) || (dmsPartInfo ? dmsPartInfo.ndp : 0);
      const mrp = physicalInfo ? physicalInfo.mrp : 0;

      const short = Math.max(0, dmsQty - physicalQty);
      const excess = Math.max(0, physicalQty - dmsQty);

      const shortageValue = short * ndp;
      const excessValue = excess * ndp;

      const totalPhysicalNdp = physicalQty * ndp;
      const totalPhysicalMrp = physicalQty * mrp;

      const originalDmsQty = initialDmsMap.get(partNo) || 0;
      const originalDmsValue = dmsQty * ndp;

      totalDms += dmsQty;
      totalPhysical += physicalQty;
      totalShort += short;
      totalExcess += excess;
      totalShortageValue += shortageValue;
      totalExcessValue += excessValue;
      totalPhysicalNdpValue += totalPhysicalNdp;
      totalPhysicalMrpValue += totalPhysicalMrp;
      totalOriginalDmsStk += originalDmsQty;
      totalOriginalDmsValue += originalDmsValue;

      detailedRows.push([
        0, partNo, description,
        dmsQty, physicalQty, short, excess,
        ndp, mrp,
        shortageValue, excessValue,
        totalPhysicalNdp, totalPhysicalMrp,
        originalDmsQty, originalDmsValue
      ]);
    }

    detailedRows.forEach((row, i) => row[0] = i + 1);

    report.push([
      '', '', 'TOTAL',
      totalDms, totalPhysical, totalShort, totalExcess,
      '', '',
      totalShortageValue, totalExcessValue,
      totalPhysicalNdpValue, totalPhysicalMrpValue,
      totalOriginalDmsStk, totalOriginalDmsValue
    ]);
    report.push(...detailedRows);

    return report;
  };

  const applyBeforeFileAdjustment = () => {
    if (!beforeData || !processedDmsMap || !processedPhysicalMap || !dmsInfoMap || !initialDmsMapForReport) {
      setError('Please upload a Before file or generate an initial report first.');
      return;
    }

    setLoading(true);
    setError('');

    setTimeout(() => {
      try {
        const beforeHeaders = beforeData[0] || [];
        const partNoBeforeIndex = findColumnIndex(beforeHeaders, ['part no', 'partno', 'part number', 'part code', 'item']);
        const qtyBeforeIndex = findColumnIndex(beforeHeaders, ['qty', 'quantity', 'stock', 'phy qty', 'count']);

        if (partNoBeforeIndex === -1 || qtyBeforeIndex === -1) {
          throw new Error('Before file must contain Part Number and Quantity columns.');
        }

        const beforeMap = new Map();
        let totalBeforeFileQty = 0;

        for (let i = 1; i < beforeData.length; i++) {
          const row = beforeData[i];
          if (!row || row.length <= Math.max(partNoBeforeIndex, qtyBeforeIndex)) {
            continue;
          }

          const partNoValue = row[partNoBeforeIndex];
          const qtyValue = row[qtyBeforeIndex];

          if (partNoValue === undefined || partNoValue === null) continue;

          const partNo = String(partNoValue).trim().toUpperCase();
          let quantity = 0;

          if (qtyValue !== undefined && qtyValue !== null) {
            if (typeof qtyValue === 'number') quantity = qtyValue;
            else if (typeof qtyValue === 'string') {
              const trimmedValue = qtyValue.trim();
              const directParse = parseFloat(trimmedValue);
              if (!isNaN(directParse)) quantity = directParse;
              else {
                const matches = trimmedValue.match(/(\d+\.?\d*)/);
                if (matches && matches[1]) quantity = parseFloat(matches[1]);
              }
            }
          }

          if (qtyValue === true) quantity = 1;

          if (partNo && quantity > 0) {
            beforeMap.set(partNo, (beforeMap.get(partNo) || 0) + quantity);
            totalBeforeFileQty += quantity;
          }
        }

        if (beforeMap.size === 0 && totalBeforeFileQty === 0) {
          throw new Error('No valid data found in the Before file. Please check that the file contains part numbers and positive quantities.');
        }

        const adjustedDmsMap = new Map(processedDmsMap);

        for (const [partNo, beforeQty] of beforeMap) {
          const existsInInitialDms = initialDmsMapForReport.has(partNo);
          if (!existsInInitialDms) continue;

          const dmsBefore = adjustedDmsMap.get(partNo) || 0;
          const dmsAfter = Math.max(0, dmsBefore - beforeQty);
          adjustedDmsMap.set(partNo, dmsAfter);
        }

        setProcessedDmsMap(adjustedDmsMap);

        const report = generateReportFromMaps(adjustedDmsMap, processedPhysicalMap, dmsInfoMap, initialDmsMapForReport);
        setReportData(report);
        setCurrentStep(1);

        setError(`Before File applied. DMS stock reduced where matched.`);
      } catch (err) {
        setError(`Error applying Before file: ${err.message}`);
      } finally {
        setLoading(false);
      }
    }, 100);
  };

  const applyAfterFileAdjustment = () => {
    if (!afterData || !processedDmsMap || !physicalData || !dmsInfoMap || !initialDmsMapForReport) {
      setError('Please upload an After file and ensure an initial report is generated.');
      return;
    }

    setLoading(true);
    setError('');

    setTimeout(() => {
      try {
        const afterHeaders = afterData[0] || [];
        const partNoAfterIndex = findColumnIndex(afterHeaders, ['PartNo', 'part no', 'part', 'code', 'item']);
        const qtyAfterIndex = findColumnIndex(afterHeaders, ['qty', 'quantity', 'phy qty', 'stock', 'count']);

        if (partNoAfterIndex === -1 || qtyAfterIndex === -1) {
          throw new Error('After file must contain Part Number and Quantity columns.');
        }

        const afterSubtractionsMap = new Map();
        for (let i = 1; i < afterData.length; i++) {
          const row = afterData[i];
          if (!row || row[partNoAfterIndex] === undefined) continue;
          const partNo = String(row[partNoAfterIndex]).trim().toUpperCase();
          const quantity = parseFloat(row[qtyAfterIndex]) || 0;
          if (partNo && quantity > 0) {
            afterSubtractionsMap.set(partNo, (afterSubtractionsMap.get(partNo) || 0) + quantity);
          }
        }

        const adjustedDmsMap = new Map(processedDmsMap);
        for (const [partNo, quantity] of afterSubtractionsMap.entries()) {
          if (adjustedDmsMap.has(partNo)) {
            const dmsBefore = adjustedDmsMap.get(partNo) || 0;
            adjustedDmsMap.set(partNo, Math.max(0, dmsBefore - quantity));
          }
        }

        const adjustedPhysicalMap = new Map(processedPhysicalMap);
        const unmatchedAfterRows = [];
        for (const [partNo, quantity] of afterSubtractionsMap.entries()) {
          if (adjustedPhysicalMap.has(partNo)) {
            const physicalInfo = adjustedPhysicalMap.get(partNo);
            physicalInfo.quantity = Math.max(0, physicalInfo.quantity - quantity);
          } else {
            unmatchedAfterRows.push({ partNo: partNo, rack: '', quantity: quantity });
          }
        }

        setProcessedDmsMap(adjustedDmsMap);
        setProcessedPhysicalMap(adjustedPhysicalMap);

        const report = generateReportFromMaps(adjustedDmsMap, adjustedPhysicalMap, dmsInfoMap, initialDmsMapForReport);
        setReportData(report);
        setCurrentStep(2);

        let successMessage = `After File adjustments applied successfully.`;
        if (unmatchedAfterRows.length > 0) {
          successMessage += ` ${unmatchedAfterRows.length} part numbers from the After file did not match any physical stock.`;
        }
        setError(successMessage);

      } catch (err) {
        setError(`Error applying After file: ${err.message}`);
      } finally {
        setLoading(false);
      }
    }, 100);
  };

  const downloadExcel = () => {
    if (!reportData) return;

    try {
      const worksheet = XLSX.utils.aoa_to_sheet(reportData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Stock Comparison Report');

      const date = new Date();
      const timestamp = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}`;

      let fileName = 'Stock_Comparison_Report';
      if (currentStep === 1) fileName += '_with_Before_Adjustment';
      if (currentStep === 2) fileName += '_with_Before_and_After_Adjustments';

      XLSX.writeFile(workbook, `${fileName}_${timestamp}.xlsx`);
    } catch (err) {
      setError(`Error downloading report: ${err.message}`);
    }
  };

  const formatNumber = (num) => {
    if (typeof num !== 'number' || isNaN(num)) return num;
    return num.toLocaleString('en-IN', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
  };

  const resetAll = () => {
    setDmsData(null);
    setPhysicalData(null);
    setBeforeData(null);
    setAfterData(null);
    setReportData(null);
    setOriginalReportData(null);
    setDmsFileName('');
    setPhysicalFileName('');
    setBeforeFileName('');
    setAfterFileName('');
    setCurrentStep(0);
    setProcessedDmsMap(null);
    setProcessedPhysicalMap(null);
    setDmsInfoMap(null);
    setInitialDmsMapForReport(null);
    setTvsTemplateData(null);
    setDealerId('');
    setBranchId('');
    setManufacturerId('');
    setBranchId('');
    setTaxableId('');
    setError('');
  };

  // TVS
  const [tvsStockTotal, setTvsStockTotal] = useState(0);
  const handleTvsStockEdit = (partNo, rack, newQuantity, rowIndex) => {
    if (tvsTemplateData && rowIndex >= 1 && rowIndex < tvsTemplateData.length) {
      const updatedTvsData = [...tvsTemplateData];
      updatedTvsData[rowIndex][8] = Math.max(0, newQuantity);

      let newTotalStock = 0;
      for (let i = 1; i < updatedTvsData.length; i++) {
        newTotalStock += parseFloat(updatedTvsData[i][8]) || 0;
      }

      setTvsTemplateData(updatedTvsData);
      setTvsStockTotal(newTotalStock);

      const updatedPhysicalMap = new Map(processedPhysicalMap);
      if (updatedPhysicalMap.has(partNo)) {
        const data = updatedPhysicalMap.get(partNo);

        let totalForPart = 0;
        for (let i = 1; i < updatedTvsData.length; i++) {
          if (updatedTvsData[i][2] === partNo) {
            totalForPart += parseFloat(updatedTvsData[i][8]) || 0;
          }
        }

        data.quantity = totalForPart;
        updatedPhysicalMap.set(partNo, data);
        setProcessedPhysicalMap(updatedPhysicalMap);

        const freshReport = generateReportFromMaps(
          processedDmsMap,
          updatedPhysicalMap,
          dmsInfoMap,
          initialDmsMapForReport,
        );
        setReportData(freshReport);
      }
    }
  };

  const generateTvsTemplate = () => {
    if (!physicalData) {
      setError('Please upload the physical stock file first.');
      return;
    }

    try {
      const physicalHeaders = physicalData[0] || [];
      const findColumn = (headers, names) => findColumnIndex(headers, names);

      const partNoIndex = findColumn(physicalHeaders, ['part no', 'partno']);
      const qtyIndex = findColumn(physicalHeaders, ['qty', 'quantity']);
      const ndpIndex = findColumn(physicalHeaders, ['ndp']);
      const mrpIndex = findColumn(physicalHeaders, ['mrp']);
      const locationIndex = findColumn(physicalHeaders, ['location']);
      const rackIndex = findColumn(physicalHeaders, ['rack']);

      if (partNoIndex === -1 || qtyIndex === -1) {
        throw new Error('Physical file must contain Part Number and Quantity columns.');
      }

      const physicalDataMap = new Map();
      const physicalPartMap = new Map();

      for (let i = 1; i < physicalData.length; i++) {
        const row = physicalData[i];
        if (!row || !row[partNoIndex]) continue;

        const partNo = String(row[partNoIndex]).trim().toUpperCase();
        const rack = rackIndex !== -1 ? String(row[rackIndex] || '').trim() : '';

        if (partNo && rack) {
          physicalDataMap.set(`${partNo}|${rack}`, true);
        }

        if (!physicalPartMap.has(partNo)) {
          physicalPartMap.set(partNo, []);
        }
        physicalPartMap.get(partNo).push(rack);
      }

      const subtractions = new Map();
      const newUnmatched = { mismatchedRack: [], emptyRack: [], partNotFound: [] };

      if (tvsAfterData) {
        const afterHeaders = tvsAfterData[0] || [];
        const partNoAfterIndex = findColumn(afterHeaders, ['PartNo', 'part no']);
        const qtyAfterIndex = findColumn(afterHeaders, ['qty', 'quantity']);
        const rackAfterIndex = findColumn(afterHeaders, ['rack']);

        if (partNoAfterIndex !== -1 && qtyAfterIndex !== -1) {
          for (let i = 1; i < tvsAfterData.length; i++) {
            const afterRow = tvsAfterData[i];
            if (!afterRow || !afterRow[partNoAfterIndex]) continue;

            const afterPartNo = String(afterRow[partNoAfterIndex]).trim().toUpperCase();
            const afterQty = parseFloat(afterRow[qtyAfterIndex]) || 0;
            const afterRack = rackAfterIndex !== -1 ? String(afterRow[rackAfterIndex] || '').trim() : '';
            const perfectMatchKey = `${afterPartNo}|${afterRack}`;

            if (afterRack && physicalDataMap.has(perfectMatchKey)) {
              subtractions.set(perfectMatchKey, (subtractions.get(perfectMatchKey) || 0) + afterQty);
            } else {
              if (!afterRack) {
                newUnmatched.emptyRack.push({ partNo: afterPartNo, quantity: afterQty });
              } else if (physicalPartMap.has(afterPartNo)) {
                newUnmatched.mismatchedRack.push({
                  partNo: afterPartNo,
                  wrongRack: afterRack,
                  quantity: afterQty,
                  availableRacks: physicalPartMap.get(afterPartNo).join(', ')
                });
              } else {
                newUnmatched.partNotFound.push({ partNo: afterPartNo, rack: afterRack, quantity: afterQty });
              }
            }
          }
        }
      }

      setUnmatchedEntries(newUnmatched);

      const tvsHeaders = ['DEALER_ID', 'BRANCH_ID', 'SPARE_PART_NO', 'MANUFACTURER_ID', 'LOCATION_ID', 'RACK', 'COST', 'TAXABLE', 'STOCK', 'MRP'];
      const tvsRows = [tvsHeaders];
      let totalStock = 0;

      for (let i = 1; i < physicalData.length; i++) {
        const row = physicalData[i];
        if (!row || !row[partNoIndex]) continue;

        const partNo = String(row[partNoIndex]).trim().toUpperCase();
        let quantity = parseFloat(row[qtyIndex]) || 0;
        const rack = rackIndex !== -1 ? String(row[rackIndex] || '').trim() : '';

        const subtractionKey = `${partNo}|${rack}`;
        if (subtractions.has(subtractionKey)) {
          quantity = Math.max(0, quantity - subtractions.get(subtractionKey));
        }

        const ndp = ndpIndex !== -1 ? parseFloat(row[ndpIndex]) || 0 : 0;
        const mrp = mrpIndex !== -1 ? parseFloat(row[mrpIndex]) || 0 : 0;
        const location = locationIndex !== -1 ? String(row[locationIndex] || '').trim() : '';

        tvsRows.push([
          dealerId || '', branchId || '', partNo, manufacturerId || '',
          location, rack, ndp, taxable || 'Y', quantity, mrp
        ]);

        totalStock += quantity;
      }

      setTvsTemplateData(tvsRows);
      setTvsStockTotal(totalStock);
      setError('TVS template generated. Subtractions were only applied to perfect Part No and Rack matches.');

    } catch (err) {
      setError(`Error generating TVS template: ${err.message}`);
      setUnmatchedEntries({ mismatchedRack: [], emptyRack: [], partNotFound: [] });
    }
  };

  const clearTvsTemplate = () => {
    setDealerId('');
    setBranchId('');
    setManufacturerId('');
    setTaxableId('');
    clearFile('tvsAfter');
    setTvsStockTotal(0);
    setUnmatchedEntries({ mismatchedRack: [], emptyRack: [], partNotFound: [] });
    setError('');
    if (tvsAfterInputRef.current) tvsAfterInputRef.current.value = null;
  };

  const downloadTvsTemplate = () => {
    if (!tvsTemplateData) return;

    try {
      const worksheet = XLSX.utils.aoa_to_sheet(tvsTemplateData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'TVS Template');

      const date = new Date();
      const timestamp = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}`;

      XLSX.writeFile(workbook, `TVS_Template_${timestamp}.xlsx`);
    } catch (err) {
      setError(`Error downloading TVS template: ${err.message}`);
    }
  };

  // Summary builder
  const buildSummary = (reportData, dupStats) => {
    if (!reportData || !dupStats) return null;

    const tot = reportData[1];

    const summary = {
      partBeforeDup: dupStats.dmsDupCount,
      partAfterDup: dupStats.dmsDupCount + dupStats.physOnlyUniqueCount,
      shortageCount: reportData.slice(2).filter(r => r[5] > 0).length,
      excessCount: reportData.slice(2).filter(r => r[6] > 0).length,
      shortageValue: tot[9],
      excessValue: tot[10],
      ndpBefore: tot[14],
      ndpAfter: tot[11],
      mrpAfter: tot[12],
      lineItemsDup: dupStats.physDupCount,
      lineItemsUnique: dupStats.physUniqueCount,
      extrasUnique: dupStats.physOnlyUniqueCount
    };

    return summary;
  };

  const summary = React.useMemo(
    () => buildSummary(reportData, dupStats),
    [reportData, dupStats, forceUpdate]
  );

  // ---------- Summary Excel helpers ----------
  const buildSummaryAoA = (s, title, reportData) => {
    if (!s) return null;
    const tot = reportData?.[1] || [];
    const mrpAfter = Number(tot[12] || 0);

    const rows = [
      [title || 'Summary', '', '', ''],
      [],
      ['Count of Part No. before audit', s.partBeforeDup, 'Count of Part No. after audit', s.partAfterDup],
      ['Count of Shortage Parts', s.shortageCount, 'Value of Shortage Parts', Number(s.shortageValue || 0)],
      ['Count of Excess Parts', s.excessCount, 'Value of Excess Parts', Number(s.excessValue || 0)],
      ['Total NDP Value before audit', Number(s.ndpBefore || 0), 'Total NDP Value after audit', Number(s.ndpAfter || 0)],
      ['No of Line item counted', s.lineItemsDup, 'Count of Extras found during audit', s.extrasUnique],
      ['No of Line item counted - Unique', s.lineItemsUnique, 'Total MRP Value after audit', mrpAfter]
    ];
    return rows;
  };

  const downloadSummaryExcel = () => {
    if (!summary) {
      setError('No summary to download.');
      return;
    }

    const rows = buildSummaryAoA(summary, summaryHeader || 'Summary', reportData);
    const ws = XLSX.utils.aoa_to_sheet(rows);

    // Merge title across 4 columns and set widths
    ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 3 } }];
    ws['!cols'] = [{ wch: 36 }, { wch: 18 }, { wch: 36 }, { wch: 22 }];

    // Apply INR format to currency cells
    const rupeeFmt = '"₹" #,##,##0.00';
    for (let r = 2; r < rows.length; r++) {
      if (typeof rows[r][1] === 'number' && /Value|NDP|MRP/i.test(rows[r][0] || '')) {
        const addr = XLSX.utils.encode_cell({ r, c: 1 });
        if (ws[addr]) { ws[addr].t = 'n'; ws[addr].z = rupeeFmt; }
      }
      if (typeof rows[r][3] === 'number' && /Value|NDP|MRP/i.test(rows[r][2] || '')) {
        const addr = XLSX.utils.encode_cell({ r, c: 3 });
        if (ws[addr]) { ws[addr].t = 'n'; ws[addr].z = rupeeFmt; }
      }
    }

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Summary');

    const dt = new Date();
    const ts = `${dt.getFullYear()}${String(dt.getMonth() + 1).padStart(2, '0')}${String(dt.getDate()).padStart(2, '0')}_${String(dt.getHours()).padStart(2, '0')}${String(dt.getMinutes()).padStart(2, '0')}`;
    XLSX.writeFile(wb, `Summary_${ts}.xlsx`);
  };

  const downloadAllExcel = () => {
    if (!reportData) {
      setError('Please generate the report first.');
      return;
    }

    try {
      const wb = XLSX.utils.book_new();

      // Sheet 1: Stock Comparison (with optional merged title)
      let repAoA = reportData;
      if (summaryHeader?.trim()) repAoA = [[summaryHeader.trim()], [], ...reportData];
      const wsReport = XLSX.utils.aoa_to_sheet(repAoA);
      if (summaryHeader?.trim()) {
        const lastCol = (reportData[0]?.length || 1) - 1;
        wsReport['!merges'] = (wsReport['!merges'] || []).concat([
          { s: { r: 0, c: 0 }, e: { r: 0, c: lastCol } }
        ]);
      }
      XLSX.utils.book_append_sheet(wb, wsReport, 'Stock Comparison');

      // Sheet 2: Summary
      if (summary) {
        const rows = buildSummaryAoA(summary, summaryHeader || 'Summary', reportData);
        const wsSum = XLSX.utils.aoa_to_sheet(rows);
        wsSum['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 3 } }];
        wsSum['!cols'] = [{ wch: 36 }, { wch: 18 }, { wch: 36 }, { wch: 22 }];

        const rupeeFmt = '"₹" #,##,##0.00';
        for (let r = 2; r < rows.length; r++) {
          if (typeof rows[r][1] === 'number' && /Value|NDP|MRP/i.test(rows[r][0] || '')) {
            const addr = XLSX.utils.encode_cell({ r, c: 1 });
            if (wsSum[addr]) { wsSum[addr].t = 'n'; wsSum[addr].z = rupeeFmt; }
          }
          if (typeof rows[r][3] === 'number' && /Value|NDP|MRP/i.test(rows[r][2] || '')) {
            const addr = XLSX.utils.encode_cell({ r, c: 3 });
            if (wsSum[addr]) { wsSum[addr].t = 'n'; wsSum[addr].z = rupeeFmt; }
          }
        }
        XLSX.utils.book_append_sheet(wb, wsSum, 'Summary');
      }

      // Sheet 3: TVS Template (if present)
      if (tvsTemplateData && tvsTemplateData.length > 0) {
        const wsTvs = XLSX.utils.aoa_to_sheet(tvsTemplateData);
        XLSX.utils.book_append_sheet(wb, wsTvs, 'TVS Template');
      }

      // Helper to append raw uploaded sheets (keeps original columns/rows)
      const addRaw = (aoa, name) => {
        if (!aoa || !aoa.length) return;
        const ws = XLSX.utils.aoa_to_sheet(aoa);
        // Excel sheet names max length 31
        XLSX.utils.book_append_sheet(wb, ws, name.slice(0, 31));
      };

      // Raw uploads
      addRaw(dmsData, 'Raw DMS');
      addRaw(physicalData, 'Raw Physical');
      addRaw(beforeData, 'Raw Before');
      addRaw(afterData, 'Raw After');

      // Safe filename: "<summaryHeader>_YYYYMMDD_HHMM.xlsx"
      const toSafeFileName = (s) =>
        (s && s.trim() ? s.trim() : 'Summary')
          .replace(/[\\/:*?"<>|]/g, '_')  // include backslash!
          .replace(/\s+/g, ' ')
          .slice(0, 150);

      const dt = new Date();
      const ts = `${dt.getFullYear()}${String(dt.getMonth() + 1).padStart(2, '0')}${String(dt.getDate()).padStart(2, '0')}_${String(dt.getHours()).padStart(2, '0')}${String(dt.getMinutes()).padStart(2, '0')}`;
      const base = toSafeFileName(summaryHeader);

      XLSX.writeFile(wb, `${base}_${ts}.xlsx`);
    } catch (err) {
      setError(`Error building workbook: ${err.message}`);
    }
  };

  return (
    <Container maxWidth="xl" sx={{ py: 3 }}>
      <Paper elevation={3} sx={{ p: 4, borderRadius: 3 }}>
        <Typography variant="h4" component="h1" gutterBottom align="center" sx={{ color: primaryColor, mb: 3 }}>
          Stock Comparison Report Generator
        </Typography>

        {reportData ? (
          <Stepper activeStep={currentStep} sx={{ mb: 4 }}>
            {steps.map((label, index) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>
        ) : (
          <Alert severity="info" sx={{ mb: 3 }}>
            <Typography variant="h6" gutterBottom>
              <Info sx={{ verticalAlign: 'middle', mr: 1 }} />
              Instructions
            </Typography>
            <ul>
              <li><strong>Step 1:</strong> Upload DMS and Physical files, then generate the initial report</li>
              <li><strong>Step 2 (Optional):</strong> Upload a Before file to adjust DMS stock quantities</li>
              <li><strong>Step 3 (Optional):</strong> Upload an After file to adjust both DMS and Physical stock</li>
            </ul>
            <Typography variant="body2" sx={{ mt: 1, fontWeight: 'bold' }}>
              Each step builds on the previous one, allowing you to see the impact of each adjustment.
            </Typography>
          </Alert>
        )}

        {error && (
          <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError('')}>
            {error}
          </Alert>
        )}

        {!reportData ? (
          <Grid container spacing={3} sx={{ mb: 4 }}>
            <Grid item xs={12} md={6}>
              <Card variant="outlined" sx={{ p: 2, position: 'relative' }}>
                {dmsData && (
                  <IconButton
                    sx={{ position: 'absolute', top: 8, right: 8 }}
                    onClick={() => clearFile('dms')}
                    size="small"
                  >
                    <Delete />
                  </IconButton>
                )}
                <CardContent sx={{ textAlign: 'center' }}>
                  <UploadFile sx={{ fontSize: 40, color: primaryColor, mb: 2 }} />
                  <Typography variant="h6" gutterBottom>
                    Upload DMS File
                  </Typography>
                  <Button
                    variant="contained"
                    component="label"
                    sx={{ backgroundColor: primaryColor, mb: 2 }}
                  >
                    Select DMS File
                    <input
                      type="file"
                      hidden
                      accept=".xlsx, .xls"
                      onChange={(e) => handleFileUpload(e, 'dms')}
                    />
                  </Button>
                  {dmsFileName && (
                    <Box>
                      <Chip
                        label={dmsFileName}
                        variant="outlined"
                        sx={{ maxWidth: '100%' }}
                        onDelete={() => clearFile('dms')}
                      />
                    </Box>
                  )}
                  <Typography variant="caption" display="block" sx={{ mt: 1, color: 'text.secondary' }}>
                    Should contain Part Numbers and <strong>Total Stock</strong>
                  </Typography>
                </CardContent>
              </Card>
            </Grid>

            <Grid item xs={12} md={6}>
              <Card variant="outlined" sx={{ p: 2, position: 'relative' }}>
                {physicalData && (
                  <IconButton
                    sx={{ position: 'absolute', top: 8, right: 8 }}
                    onClick={() => clearFile('physical')}
                    size="small"
                  >
                    <Delete />
                  </IconButton>
                )}
                <CardContent sx={{ textAlign: 'center' }}>
                  <UploadFile sx={{ fontSize: 40, color: primaryColor, mb: 2 }} />
                  <Typography variant="h6" gutterBottom>
                    Upload Physical File
                  </Typography>
                  <Button
                    variant="contained"
                    component="label"
                    sx={{ backgroundColor: primaryColor, mb: 2 }}
                  >
                    Select Physical File
                    <input
                      type="file"
                      hidden
                      accept=".xlsx, .xls"
                      onChange={(e) => handleFileUpload(e, 'physical')}
                    />
                  </Button>
                  {physicalFileName && (
                    <Box>
                      <Chip
                        label={physicalFileName}
                        variant="outlined"
                        sx={{ maxWidth: '100%' }}
                        onDelete={() => clearFile('physical')}
                      />
                    </Box>
                  )}
                  <Typography variant="caption" display="block" sx={{ mt: 1, color: 'text.secondary' }}>
                    Should contain Part Numbers, Quantities, NDP, and MRP
                  </Typography>
                </CardContent>
              </Card>
            </Grid>

            <Grid item xs={12} sx={{ textAlign: 'center', mt: 2 }}>
              <Button
                variant="contained"
                onClick={generateInitialReport}
                disabled={!dmsData || !physicalData || loading}
                startIcon={<CompareArrows />}
                sx={{
                  backgroundColor: '#2ecc71',
                  padding: '12px 24px',
                  fontSize: '16px',
                  '&:hover': { backgroundColor: '#27ae60' },
                  '&:disabled': { backgroundColor: '#cccccc' }
                }}
              >
                {loading ? 'Generating Report...' : 'Generate Initial Report'}
              </Button>
            </Grid>
          </Grid>
        ) : (
          currentStep < 2 && (
            <Card variant="outlined" sx={{ p: 2, mb: 4 }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {currentStep === 0 ? 'Optional: Apply "Before" Adjustments' : 'Optional: Apply "After" Adjustments'}
                </Typography>
                <Typography variant="body2" sx={{ mb: 2 }}>
                  {currentStep === 0 ?
                    'Upload a Before file to adjust DMS stock quantities (reduces DMS stock only)' :
                    'Upload an After file to adjust both DMS and Physical stock quantities'
                  }
                </Typography>

                <Grid container spacing={2} alignItems="center">
                  <Grid item xs={12} md={6}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Button variant="contained" component="label" sx={{ mr: 2 }}>
                        {currentStep === 0 ? 'Select Before File' : 'Select After File'}
                        <input
                          type="file"
                          hidden
                          accept=".xlsx, .xls"
                          onChange={(e) => handleFileUpload(e, currentStep === 0 ? 'before' : 'after')}
                        />
                      </Button>
                      {currentStep === 0 ? (
                        beforeFileName ? (
                          <Chip label={beforeFileName} variant="outlined" onDelete={() => clearFile('before')} />
                        ) : null
                      ) : (
                        afterFileName ? (
                          <Chip label={afterFileName} variant="outlined" onDelete={() => clearFile('after')} />
                        ) : null
                      )}
                    </Box>
                  </Grid>
                  <Grid item xs={12} md={6} sx={{ textAlign: 'right' }}>
                    <Button
                      variant="contained"
                      onClick={currentStep === 0 ? applyBeforeFileAdjustment : applyAfterFileAdjustment}
                      disabled={currentStep === 0 ? !beforeData : !afterData}
                      startIcon={<NavigateNext />}
                      sx={{ backgroundColor: '#3498db', '&:hover': { backgroundColor: '#2980b9' } }}
                    >
                      {loading ? 'Applying...' : `Apply ${currentStep === 0 ? 'Before' : 'After'} Adjustment`}
                    </Button>
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          )
        )}

        {loading && (
          <Box sx={{ width: '100%', mb: 3 }}>
            <LinearProgress />
          </Box>
        )}

        {reportData && (
          <Box>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
              <Typography variant="h5" gutterBottom sx={{ color: primaryColor }}>
                Stock Comparison Report
                {currentStep === 1 && ' (with Before Adjustment)'}
                {currentStep === 2 && ' (with Before & After Adjustments)'}
              </Typography>

              <Box>
                <Button
                  variant="contained"
                  onClick={downloadExcel}
                  startIcon={<Download />}
                  sx={{ backgroundColor: '#9b59b6', mr: 2, '&:hover': { backgroundColor: '#8e44ad' } }}
                >
                  Download Excel
                </Button>
                <Button variant="outlined" onClick={resetAll} sx={{ borderColor: primaryColor, color: primaryColor }}>
                  Start New Comparison
                </Button>
              </Box>
            </Box>

            <Box sx={{ height: 600, width: '100%', mb: 3 }}>
              <DataGrid
                {...buildGridData(reportData)}
                density="compact"
                experimentalFeatures={{ newEditingApi: true }}
                processRowUpdate={(newRow, oldRow) => {
                  if (newRow.STOCK !== oldRow.STOCK) {
                    const partNo = newRow.SPARE_PART_NO;
                    const rack = newRow.RACK;
                    const newQuantity = parseFloat(newRow.STOCK) || 0;
                    const rowIndex = newRow.id;
                    handleTvsStockEdit(partNo, rack, newQuantity, rowIndex);
                  }
                  return newRow;
                }}
                onProcessRowUpdateError={(err) => console.error(err)}
                sx={{
                  '& .MuiDataGrid-columnHeaders': {
                    backgroundColor: '#ffffffff',
                    color: '#16407cff',
                    fontSize: 22,
                    fontStyle: 'bold',
                  }
                }}
              />
            </Box>

            <Box sx={{ overflowX: 'auto', mb: 3 }}>
              <Box sx={{ display: 'flex', minWidth: 1100 }}>
                {reportData[1].map((cell, idx) => (
                  <Box
                    key={idx}
                    sx={{
                      flex: 1,
                      p: 1,
                      backgroundColor: '#2c3e50',
                      color: '#fff',
                      fontWeight: 'bold',
                      textAlign: typeof cell === 'number' ? 'right' : 'left',
                      fontFamily: typeof cell === 'number' ? 'monospace' : 'inherit'
                    }}
                  >
                    {typeof cell === 'number' ? formatNumber(cell) : cell}
                  </Box>
                ))}
              </Box>
            </Box>

            <Alert severity="success">
              Report generated successfully! Found {reportData.length - 2} part records.
              {currentStep === 1 && ' DMS quantities have been adjusted using the Before file.'}
              {currentStep === 2 && ' DMS and Physical quantities have been adjusted using the After file.'}
            </Alert>

            {summary && (
              <>
                {/* Summary controls: heading input + buttons */}
                <Box sx={{ mb: 2, mt: 2 }}>
                  <Grid container spacing={1} alignItems="center">
                    <Grid item xs={12} md={8}>
                      <TextField
                        fullWidth
                        size="small"
                        label="Summary Heading (Dealer/Showroom)"
                        placeholder="11030-TRIJAL MOTORS - RAMAGONDANAHALLI"
                        value={summaryHeader}
                        onChange={(e) => setSummaryHeader(e.target.value)}
                      />
                    </Grid>

                    <Grid item xs={12}>
                      <Paper
                        elevation={0}
                        sx={{
                          mt: 0,
                          backgroundColor: primaryColor,
                          color: '#fff',
                          p: 1,
                          textAlign: 'center',
                          fontWeight: 'bold',
                          borderRadius: 1
                        }}
                      >
                        {summaryHeader || '<-- Enter the Summary Heading Here'}
                      </Paper>
                    </Grid>
                    <Grid item xs={12} md={4} sx={{ textAlign: { xs: 'left', md: 'right' } }}>
                      <Button
                        variant="contained"
                        color='secondary'
                        startIcon={<Download />}
                        onClick={downloadSummaryExcel}
                        disabled={!summary}
                        sx={{ mr: 1 }}
                      >
                        Download Summary
                      </Button>
                    </Grid>
                  </Grid>
                </Box>

                {/* Summary cards */}
                <Grid container spacing={2} sx={{ mt: 1 }}>
                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#ecf0f1' }}>
                      <Typography fontWeight="bold">Count of Part No. before audit</Typography>
                      <Typography variant="h6">{summary.partBeforeDup.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#ecf0f1' }}>
                      <Typography fontWeight="bold">Count of Part No. after audit</Typography>
                      <Typography variant="h6">{summary.partAfterDup.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#e8f7ff' }}>
                      <Typography fontWeight="bold">Count of Shortage Parts</Typography>
                      <Typography variant="h6">{summary.shortageCount.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#e8f7ff' }}>
                      <Typography fontWeight="bold">Value of Shortage Parts</Typography>
                      <Typography variant="h6">
                        ₹&nbsp;{summary.shortageValue.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                      </Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#fcefe6' }}>
                      <Typography fontWeight="bold">Count of Excess Parts</Typography>
                      <Typography variant="h6">{summary.excessCount.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#fcefe6' }}>
                      <Typography fontWeight="bold">Value of Excess Parts</Typography>
                      <Typography variant="h6">
                        ₹&nbsp;{summary.excessValue.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                      </Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2 }}>
                      <Typography fontWeight="bold">Total NDP Value before audit</Typography>
                      <Typography variant="h6">
                        ₹&nbsp;{summary.ndpBefore.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                      </Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2 }}>
                      <Typography fontWeight="bold">Total NDP Value after audit</Typography>
                      <Typography variant="h6">
                        ₹&nbsp;{summary.ndpAfter.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                      </Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#fff4e6' }}>
                      <Typography fontWeight="bold">Total MRP Value after audit</Typography>
                      <Typography variant="h6">
                        ₹&nbsp;{summary.mrpAfter.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                      </Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#ddeff5' }}>
                      <Typography fontWeight="bold">No of Line item counted</Typography>
                      <Typography variant="h6">{summary.lineItemsDup.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#ddeff5' }}>
                      <Typography fontWeight="bold">No of Line item counted – Unique</Typography>
                      <Typography variant="h6">{summary.lineItemsUnique.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <Paper sx={{ p: 2, backgroundColor: '#fff4e6' }}>
                      <Typography fontWeight="bold">Count of Extras found during audit</Typography>
                      <Typography variant="h6">{summary.extrasUnique.toLocaleString()}</Typography>
                    </Paper>
                  </Grid>
                </Grid>
              </>
            )}

            {/* TVS Template Section */}
            <Box sx={{ mt: 4 }}>
              <Typography variant="h5" gutterBottom sx={{ color: primaryColor, mb: 2 }}>
                TVS Template Generator
              </Typography>

              <Card variant="outlined" sx={{ p: 3, mb: 3 }}>
                <Grid container spacing={2} alignItems="center">
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" gutterBottom sx={{ fontWeight: 'bold' }}>
                      Step 1: Upload After File for TVS Template
                    </Typography>
                    <Box sx={{ display: 'flex', alignItems: 'center', p: 2, border: '1px dashed grey', borderRadius: 1 }}>
                      <Button variant="contained" component="label" sx={{ mr: 2 }}>
                        Select TVS After File
                        <input
                          ref={tvsAfterInputRef}
                          type="file"
                          hidden
                          accept=".xlsx, .xls"
                          onClick={e => { e.target.value = null; }}
                          onChange={(e) => handleFileUpload(e, 'tvsAfter')}
                        />
                      </Button>
                      {tvsAfterFileName && (
                        <Chip
                          label={tvsAfterFileName}
                          variant="outlined"
                          onDelete={() => clearFile('tvsAfter')}
                        />
                      )}
                    </Box>
                  </Grid>
                  <Grid item xs={12}>
                    <Typography variant="subtitle1" gutterBottom sx={{ fontWeight: 'bold', mt: 2 }}>
                      Step 2: Enter IDs
                    </Typography>
                  </Grid>
                  <Grid item xs={10} md={2}>
                    <TextField fullWidth label="DEALER_ID" value={dealerId} onChange={(e) => setDealerId(e.target.value)} size="small" />
                  </Grid>
                  <Grid item xs={10} md={2}>
                    <TextField label="BRANCH_ID" value={branchId} onChange={(e) => setBranchId(e.target.value)} size="small" />
                  </Grid>
                  <Grid item xs={10} md={2}>
                    <TextField label="MANUFACTURER_ID" value={manufacturerId} onChange={(e) => setManufacturerId(e.target.value)} size="small" />
                  </Grid>
                  <Grid item xs={10} md={2}>
                    <TextField label="TAXABLE" value={taxable} onChange={(e) => setTaxableId(e.target.value)} size="small" />
                  </Grid>
                  <Grid item xs={12} sx={{ textAlign: 'center', mt: 2 }}>
                    <Typography variant="subtitle1" gutterBottom sx={{ fontWeight: 'bold', mb: 1 }}>
                      Step 3: Generate
                    </Typography>
                    <Button
                      variant="contained"
                      onClick={generateTvsTemplate}
                      disabled={!physicalData}
                      sx={{ backgroundColor: '#e67e22', mr: 2, '&:hover': { backgroundColor: '#d35400' } }}
                    >
                      Generate TVS Template
                    </Button>
                    <Button variant="outlined"
                      color='secondary' onClick={downloadTvsTemplate} disabled={!tvsTemplateData} startIcon={<Download />}>
                      Download TVS Template
                    </Button>
                    <Button variant="outlined" color="error" onClick={clearTvsTemplate} startIcon={<Delete />}>
                      Clear TVS Inputs
                    </Button>
                  </Grid>
                </Grid>
              </Card>

              {tvsTemplateData && (
                <Box>
                  <Box sx={{ height: 400, width: '100%', mb: 3 }}>
                    <DataGrid
                      rows={tvsTemplateData.slice(1).map((row, index) => {
                        const rowObj = { id: index + 1 };
                        tvsTemplateData[0].forEach((header, i) => {
                          rowObj[header] = row[i];
                        });
                        return rowObj;
                      })}
                      columns={tvsTemplateData[0].map(header => ({
                        field: header,
                        headerName: header,
                        flex: 1,
                        editable: header === 'STOCK' || header === 'TAXABLE',
                      }))}
                      density="compact"
                      processRowUpdate={(newRow, oldRow) => {
                        const partNo = newRow.SPARE_PART_NO;
                        const rack = newRow.RACK;
                        const newQuantity = parseFloat(newRow.STOCK) || 0;

                        const rowIndex = tvsTemplateData.findIndex(
                          (row, idx) => idx > 0 && row[2] === partNo && row[5] === rack
                        );

                        if (rowIndex > 0) {
                          handleTvsStockEdit(partNo, rack, newQuantity, rowIndex);
                        }
                        return newRow;
                      }}
                      onProcessRowUpdateError={(err) => console.error(err)}
                      sx={{
                        '& .MuiDataGrid-columnHeaders': {
                          backgroundColor: '#ffffffff',
                          color: '#16407cff',
                          fontSize: 16,
                        }
                      }}
                    />
                  </Box>

                  <Box sx={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center', p: 2, backgroundColor: '#f5f5f5', borderRadius: 1, mb: 3 }}>
                    <Typography variant="h6" sx={{ mr: 2, fontWeight: 'bold' }}>
                      Total Stock in TVS Template:
                    </Typography>
                    <Typography variant="h5" sx={{ color: primaryColor, fontWeight: 'bold' }}>
                      {formatNumber(tvsStockTotal)}
                    </Typography>
                  </Box>

                  {reportData && reportData.length > 1 && (
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', p: 2, backgroundColor: '#e8f5e8', borderRadius: 1, mb: 3 }}>
                      <Box>
                        <Typography variant="body1" sx={{ fontWeight: 'bold' }}>
                          Report Physical Total: {formatNumber(reportData[1][4])}
                        </Typography>
                        <Typography variant="body1" sx={{ fontWeight: 'bold' }}>
                          TVS Template Total: {formatNumber(tvsStockTotal)}
                        </Typography>
                      </Box>
                      <Box>
                        {Math.abs(reportData[1][4] - tvsStockTotal) <= 0.01 ? (
                          <Chip label="Totals Match" color="success" variant="outlined" />
                        ) : (
                          <Chip label="Totals Don't Match" color="error" variant="outlined" />
                        )}
                      </Box>
                    </Box>
                  )}

                  {unmatchedEntries.mismatchedRack.length > 0 && (
                    <Alert severity="warning" sx={{ mt: 2 }}>
                      <Typography variant="subtitle1" fontWeight="bold">Mismatched Rack (No Subtraction Occurred)</Typography>
                      <TableContainer component={Paper} sx={{ mt: 1 }}>
                        <Table size="small">
                          <TableHead>
                            <TableRow>
                              <TableCell>Part No</TableCell>
                              <TableCell>Wrong Rack in After File</TableCell>
                              <TableCell>Qty</TableCell>
                              <TableCell>Available Racks in Physical</TableCell>
                            </TableRow>
                          </TableHead>
                          <TableBody>
                            {unmatchedEntries.mismatchedRack.map((row, idx) => (
                              <TableRow key={idx}>
                                <TableCell>{row.partNo}</TableCell>
                                <TableCell>{row.wrongRack}</TableCell>
                                <TableCell>{row.quantity}</TableCell>
                                <TableCell>{row.availableRacks}</TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Alert>
                  )}

                  {unmatchedEntries.emptyRack.length > 0 && (
                    <Alert severity="info" sx={{ mt: 2 }}>
                      <Typography variant="subtitle1" fontWeight="bold">Empty Rack in After File (No Subtraction Occurred)</Typography>
                      <TableContainer component={Paper} sx={{ mt: 1 }}>
                        <Table size="small">
                          <TableHead><TableRow><TableCell>Part No</TableCell><TableCell>Qty</TableCell></TableRow></TableHead>
                          <TableBody>
                            {unmatchedEntries.emptyRack.map((row, idx) => (
                              <TableRow key={idx}><TableCell>{row.partNo}</TableCell><TableCell>{row.quantity}</TableCell></TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Alert>
                  )}

                  {unmatchedEntries.partNotFound.length > 0 && (
                    <Alert severity="error" sx={{ mt: 2 }}>
                      <Typography variant="subtitle1" fontWeight="bold">Part Not Found in Physical Stock (No Subtraction Occurred)</Typography>
                      <TableContainer component={Paper} sx={{ mt: 1 }}>
                        <Table size="small">
                          <TableHead><TableRow><TableCell>Part No</TableCell><TableCell>Rack</TableCell><TableCell>Qty</TableCell></TableRow></TableHead>
                          <TableBody>
                            {unmatchedEntries.partNotFound.map((row, idx) => (
                              <TableRow key={idx}><TableCell>{row.partNo}</TableCell><TableCell>{row.rack}</TableCell><TableCell>{row.quantity}</TableCell></TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Alert>
                  )}

                </Box>
              )}
            </Box><br></br>
          </Box>
        )}          <Box sx={{ width: '100%', display: 'flex', justifyContent: 'center', mt: 2 }}>
          <Button
            variant="contained"
            color="secondary"
            startIcon={<Download />}
            onClick={downloadAllExcel}
            disabled={!reportData}
            sx={{
              px: 8,
              py: 1.25,
              borderRadius: 2,
              textTransform: 'none'
            }} >

            DOWNLOAD ALL FILES
          </Button>
        </Box>

      </Paper>
    </Container>
  );
};

export default StockComparison;