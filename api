// src/services/api.js
import axios from 'axios';
import authManager from './authsession';

const BASE_URL = 'https://pas-av9v.onrender.com/api';

// Create axios instance
const client = axios.create({
  baseURL: BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

// Request interceptor
client.interceptors.request.use(
  async (config) => {
    try {
      const token = await authManager.getAuthToken();
      if (token) {
        config.headers['Authorization'] = `Bearer ${token}`;
      }
    } catch (error) {
      console.error('Request interceptor error:', error);
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor
client.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      await authManager.logout();
    }
    return Promise.reject(error);
  }
);

// API methods
const api = {
  // Generic HTTP methods
  get: (url, config) => client.get(url, config),
  post: (url, data, config) => client.post(url, data, config),
  put: (url, data, config) => client.put(url, data, config),
  delete: (url, config) => client.delete(url, config),
  
  // Auth endpoints
  login: (email, password) => client.post('/auth/login', { email, password }).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      const token = responseBody.token;
      const user = responseBody.user;
      return authManager.saveUserSession(token, user).then(() => ({
        success: true,
        user
      }));
    } else {
      return {
        success: false,
        message: responseBody.message || 'Login failed',
      };
    }
  }).catch(error => {
    console.error('Login Error:', error);
    if (error.response) {
      return {
        success: false,
        message: error.response.data.message || 'Server error during login',
      };
    } else {
      return {
        success: false,
        message: `Network error during login: ${error.message}`,
      };
    }
  }),
  
  logout: () => authManager.logout(),
  
  // User endpoints
  getAllUsers: () => client.get('/auth/users').then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return responseBody.users;
    } else {
      throw new Error(responseBody.message || 'Failed to load users');
    }
  }),
  
  getUsersByRole: (role) => client.get(`/auth/users/role/${role}`).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return responseBody.users;
    } else {
      throw new Error(responseBody.message || 'Failed to load users by role');
    }
  }),
  
  createUser: (userData) => client.post('/auth/register', userData).then(response => {
    const responseBody = response.data;
    if (response.status === 201 && responseBody.success) {
      return {
        success: true,
        message: responseBody.message || 'User created successfully',
        user: responseBody.user,
      };
    } else {
      return {
        success: false,
        message: responseBody.message || 'Failed to create user',
      };
    }
  }).catch(error => {
    console.error('Create User Error:', error);
    if (error.response) {
      return {
        success: false,
        message: error.response.data.message || 'Server error creating user',
      };
    } else {
      return {
        success: false,
        message: `Network error creating user: ${error.message}`,
      };
    }
  }),
  
  updateUser: (userId, userData) => client.put(`/auth/users/${userId}`, userData).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return {
        success: true,
        message: responseBody.message,
        user: responseBody.user,
      };
    } else {
      return {
        success: false,
        message: responseBody.message || 'Failed to update user',
      };
    }
  }).catch(error => {
    console.error('Update User Error:', error);
    if (error.response) {
      return {
        success: false,
        message: error.response.data.message || 'Server error during user update',
      };
    } else {
      return {
        success: false,
        message: `Network error during user update: ${error.message}`,
      };
    }
  }),
  
deleteUser: (userId) => client.delete(`/auth/users/${userId}`).then(response => {
  const responseBody = response.data;
  if (response.status === 200 && responseBody.success) {
    return { success: true, message: responseBody.message };
  } else {
    return {
      success: false,
      message: responseBody.message || 'Failed to delete user',
    };
  }
}).catch(error => {
  console.error('Delete User Error:', error);
  if (error.response) {
    return {
      success: false,
      message: error.response.data.message || 'Server error during user deletion',
    };
  } else {
    return {
      success: false,
      message: `Network error during user deletion: ${error.message}`,
    };
  }
}),
  
  // Team endpoints
  getTeams: () => client.get('/teams').then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return responseBody.teams;
    } else {
      throw new Error(responseBody.message || 'Failed to load teams');
    }
  }),
  
  getTeamById: (teamId) => client.get(`/teams/${teamId}`).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return responseBody.team;
    } else {
      throw new Error(responseBody.message || 'Failed to load team');
    }
  }),
  
  createTeam: (teamData) => client.post('/teams', teamData).then(response => {
    const responseBody = response.data;
    if (response.status === 201 && responseBody.success) {
      return {
        success: true,
        message: responseBody.message,
        team: responseBody.team,
      };
    } else {
      return {
        success: false,
        message: responseBody.message || 'Team creation failed',
      };
    }
  }).catch(error => {
    console.error('Create Team Error:', error);
    if (error.response) {
      return {
        success: false,
        message: error.response.data.message || 'Server error during team creation',
      };
    } else {
      return {
        success: false,
        message: `Network error during team creation: ${error.message}`,
      };
    }
  }),
  
  updateTeam: (teamId, teamData) => client.put(`/teams/${teamId}`, teamData).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return {
        success: true,
        message: responseBody.message,
        team: responseBody.team,
      };
    } else {
      return {
        success: false,
        message: responseBody.message || 'Failed to update team',
      };
    }
  }).catch(error => {
    console.error('Update Team Error:', error);
    if (error.response) {
      return {
        success: false,
        message: error.response.data.message || 'Server error during team update',
      };
    } else {
      return {
        success: false,
        message: `Network error during team update: ${error.message}`,
      };
    }
  }),
  
  deleteTeam: (teamId) => client.delete(`/teams/${teamId}`).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return { success: true, message: responseBody.message };
    } else {
      return {
        success: false,
        message: responseBody.message || 'Failed to delete team',
      };
    }
  }).catch(error => {
    console.error('Delete Team Error:', error);
    if (error.response) {
      return {
        success: false,
        message: error.response.data.message || 'Server error during team deletion',
      };
    } else {
      return {
        success: false,
        message: `Network error during team deletion: ${error.message}`,
      };
    }
  }),
  
  getTeamsForLeader: (leaderId) => client.get(`/teams/leader/${leaderId}`).then(response => {
    const responseBody = response.data;
    if (response.status === 200 && responseBody.success) {
      return responseBody.teams;
    } else {
      throw new Error(responseBody.message || 'Failed to load teams for leader');
    }
  }),
  
  // Master description endpoints
  uploadMasterDescriptions: (entries, filename) => client.post('/masterdesc/upload', {
    entries,
    filename
  }).then(response => response.data),
  
  getUploadedFilesMetadata: () => client.get('/masterdesc/files').then(response => response.data),
  
  deleteUploadedFile: (fileId) => client.delete(`/masterdesc/files/${fileId}`).then(response => response.data),
  

  // Rack endpoints - Add these to your existing api object
  getRacks: (params = {}) => client.get('/racks', { params }).then(response => {
    const responseData = response.data;
    if (response.status === 200 && responseData.success) {
      // Handle different data formats as in Flutter
      let rackJsonList = [];
      const data = responseData.data;
      
      if (Array.isArray(data)) {
        rackJsonList = data;
      } else if (typeof data === 'object' && data !== null) {
        rackJsonList = Object.values(data);
      }
      
      return {
        racks: rackJsonList,
        totalCount: parseInt(responseData.count) || 0
      };
    } else {
      throw new Error(responseData.message || 'Failed to load racks');
    }
  }),
  
  exportAllRacks: (params = {}) => client.get('/racks/export', { params }).then(response => {
    const responseData = response.data;
    if (response.status === 200 && responseData.success) {
      return responseData.data || [];
    } else {
      throw new Error(responseData.message || 'Failed to export racks');
    }
  }),
  
  getRackById: (rackId) => client.get(`/racks/${rackId}`).then(response => {
    const responseData = response.data;
    if (response.status === 200 && responseData.success) {
      return responseData.data;
    } else {
      throw new Error(responseData.message || 'Failed to load rack');
    }
  }).catch(error => {
    if (error.response) {
      throw new Error(error.response.data.message || 'Server error fetching rack by ID');
    } else {
      throw new Error(`Network error fetching rack by ID: ${error.message}`);
    }
  }),  

  updateRack: (rackId, rackData) => client.put(`/racks/${rackId}`, rackData).then(response => {
    const responseData = response.data;
    if (response.status === 200 && responseData.success) {
      return responseData;
    } else {
      throw new Error(responseData.message || 'Failed to update rack');
    }
  }).catch(error => {
    if (error.response) {
      throw new Error(error.response.data.message || 'Server error updating rack');
    } else {
      throw new Error(`Network error updating rack: ${error.message}`);
    }
  }),
  
  deleteRack: (rackId) => client.delete(`/racks/${rackId}`).then(response => {
    const responseData = response.data;
    if (response.status === 200 && responseData.success) {
      return responseData;
    } else {
      throw new Error(responseData.message || 'Failed to delete rack');
    }
  }).catch(error => {
    if (error.response) {
      throw new Error(error.response.data.message || 'Server error deleting rack');
    } else {
      throw new Error(`Network error deleting rack: ${error.message}`);
    }
  }),
  
  getTotalScanCounts: (teamId) => client.get('/racks/scancounts', { 
    params: { teamId } 
  }).then(response => {
    if (response.data.success === true) {
      const countsData = response.data.data || [];
      return countsData.reduce((acc, item) => {
        acc[item.userName || 'Unknown'] = item.count || 0;
        return acc;
      }, {});
    } else {
      throw new Error('Failed to load scan counts');
    }
  }).catch(error => {
    console.error('Error fetching scan counts:', error);
    return {}; // Return empty object on failure
  }),
  
  getFirstScanByUser: (teamId, date) => {
    // Format date as YYYY-MM-DD
    const formattedDate = new Date(date).toISOString().split('T')[0];
    
    return client.get('/racks/first-scan-by-user', {
      params: { teamId, date: formattedDate }
    }).then(response => {
      if (response.status !== 200) {
        throw new Error(response.data.error || 'API Error');
      }
      
      // Handle different response formats
      let data = response.data;
      if (response.data.success && response.data.data) {
        data = response.data.data;
      }
      
      return Object.keys(data).reduce((acc, user) => {
        const value = data[user];
        let firstScanTime = null;
        
        if (value && typeof value === 'object') {
          // Handle object format
          if (value.firstScan) {
            try {
              let dateTimeString = value.firstScan;
              if (!dateTimeString.includes('Z') && !dateTimeString.includes('+')) {
                dateTimeString += 'Z'; // Assume UTC if no timezone specified
              }
              firstScanTime = new Date(dateTimeString);
            } catch (e) {
              console.error('Error parsing datetime:', value.firstScan, e);
            }
          }
          
          acc[user] = {
            count: value.count || 0,
            firstScan: firstScanTime
          };
        } else {
          // Handle simple value format
          acc[user] = {
            count: typeof value === 'number' ? value : 0,
            firstScan: null
          };
        }
        
        return acc;
      }, {});
    }).catch(error => {
      console.error('Error in getFirstScanByUser:', error);
      return {}; // Return empty object on error
    });
  },
  
  saveExportedRacks: (rows) => client.post('/exported-rack-views/rack-view', { rows })
    .then(response => response.data),
  
  completeTeamWork: (teamId) => client.put(`/teams/${teamId}/complete`)
  .then(response => response.data)
  .catch(error => {
    if (error.response?.data) {
      return error.response.data;
    }
    return {
      success: false,
      message: error.message || 'Unknown error occurred',
    };
  }),

getTeamWorkStatus: (teamId) => client.get(`/teams/${teamId}/status`)
  .then(response => {
    if (response.data.success === true) {
      return response.data.isSubmitted || false;
    }
    return false;
  })
  .catch(error => {
    console.error('Error checking team status:', error);
    return false;
  }),

saveExportedRacksSnapshot: (snapshotsData, teamId, siteName) => 
  client.post('/exported-racks-snapshot', {
    snapshots: snapshotsData,
    teamId,
    siteName
  }).then(response => response.data)
  .catch(error => {
    return {
      success: false,
      message: error.response?.data?.message || 'Server error saving snapshot',
    };
  })
  };
export default api;